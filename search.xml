<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试题day1]]></title>
    <url>%2F2018%2F01%2F22%2F%E9%9D%A2%E8%AF%95%E9%A2%98day1%2F</url>
    <content type="text"><![CDATA[HTML,HTTP,web综合问题汇总1. 前端需要注意哪些SEO 合理的title/description/keywords:搜索对这三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过两次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范： 语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前： 搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出： 爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度： 网站速度是搜索引擎排序的一个重要指标 2. img标签的title和alt有什么区别 alt是alternative的缩写意思是可供替换的，也就是说当图片加载不出来时，会在图片位置替换显示alt属性的内容 而title标签则是该图片的标题名称，当鼠标移动到图片上时会显示出来 3. HTTP的几种请求方法用途 GET方法:发送一个请求来取得服务器上的某一资源 POST方法:向URL指定的资源提交数据或附加新的数据 PUT方法:跟POST方法很像，也是向服务器提交数据。但是，他们之间有不同。PUT指定了资源在服务器上的位置，而POST没有 HEAD方法:只请求页面的首部 DELETE方法:删除服务器上的某资源 OPTITIONS方法:它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET，POST”这样的信息 TRACE方法:TRACE方法被用于激发一个远程的，应用层的请求的消息回路 CONNECT方法:把请求连接转换到透明的TCP/IP通道 4. 从浏览器地址栏输入url到显示页面的步骤 浏览器根据请求的url交给dns域名解析，找到真实IP，向服务器发起请求 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图像等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，简历相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成 5. 如何进行网站性能优化 content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名 减少DOM元素数量 Server方面 使用CDN 配置ETag 对组件使用Gzip压缩 Cookie方面 减小cookie大小 Css方面 将样式表放到页面顶部 不适用CSS表达式 使用不适用@import JavaScript方面 将脚本放到页面底部 将javascript和css 从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要再HTML中拉伸图片]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs代码风格指南]]></title>
    <url>%2F2017%2F12%2F14%2Fvuejs%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[优先级A： 必要的组件名应为多个单词组件名应该始终为多个单词，跟组件App除外。这样做可以有效的避免跟现有的以及将会出现的HTML元素冲突，因为所有的HTML元素名称都是单个单词的。 组件数据组件的data必须是一个函数。挡在组件中使用data属性时，它的值必须是返回一个对象的函数。 prop定义prop的定义应该尽量详细。细致的 prop 定义有两个好处： 它们写明了组件的 API，所以很容易看懂组件的用法； 在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。 为 v-for设置键值总是用key配合v-for在组件中必须用key配合v-for，以便维护内部组件及子树的状态。甚至在元素上维护可预测的行为，比如动画中的对象固化，也是一种好的做法。 #为组件样式设置作用域对于应用来说，顶级App组件和布局组件中的样式可以使全局的，但是其它所有组件都应该是有作用域的。这条规则只和单文件组件有关。你不一定要使用scoped特性。设置作用域也可以通过css Modules，那是一个基于class的类似BEM的策略，当然你也可以使用其它的库或约定。不管怎样，对于组件库，我们应该更倾向于选用基于class的策略而不是scoped特性。这让覆写内部样式更容易：使用了常人可理解的class名称且没有太高的选择器优先级，而且不太会导致冲突。123456789101112131415&lt;template&gt; &lt;button class=&quot;button button-close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 `scoped` 特性 --&gt;&lt;style scoped&gt;.button &#123; border: none; border-radius: 2px;&#125;.button-close &#123; background-color: red;&#125;&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button :class=&quot;[$style.button, $style.buttonClose]&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 CSS Modules --&gt;&lt;style module&gt;.button &#123; border: none; border-radius: 2px;&#125;.buttonClose &#123; background-color: red;&#125;&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button class=&quot;c-Button c-Button--close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 BEM 约定 --&gt;&lt;style&gt;.c-Button &#123; border: none; border-radius: 2px;&#125;.c-Button--close &#123; background-color: red;&#125;&lt;/style&gt; 私有属性名在插件、混入等扩展中始终为自定义的私有属性使用$_前缀。并附带一个命名空间以回避和其它作者的冲突 优先级B： 强烈推荐优先级A： 推荐优先级A： 谨慎使用]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli基于web-pack的脚手架分析]]></title>
    <url>%2F2017%2F12%2F10%2Fvue-cli%E5%9F%BA%E4%BA%8Eweb-pack%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[源自技术胖学习教程 vue-cli的目录结构12345678910111213141516171819202122232425262728|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue公共组件| |-- store // vuex的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico |-- index.html // 入口页面|-- package.json // 项目基本信息 package.json中的dependencies字段和devDependencies字段 dependencies字段指项目运行时所依赖的模块，又称生产环境所依赖的模块 devDevpendencies字段指定了项目开发时所依赖的模块，又称开发环境所依赖的模块 webpack相关配置文件讲解上面注释中已经讲到了，build文件夹下的文件是关于webpack的配置信息 那么我们来看一下dev-server.js文件中内容的相关注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//检查Node和npm版本require(&apos;/check-versions&apos;)//获取config/index.js的默认配置var config = require(&apos;../config&apos;)//如果Node的环境无法判断当前是dev还是product环境//使用config.dev.env.NODE_ENV作为当前的环境if(!process.env.NODE_ENV) process.evn.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)//使用NodeJS自带的文件路径工具var path = require(&apos;path&apos;)// 使用 expressvar express = require(&apos;express&apos;)// 使用 webpackvar webpack = require(&apos;webpack&apos;)// 一个可以强制打开浏览器并跳转到指定 url 的插件var opn = require(&apos;opn&apos;)// 使用 proxyTablevar proxyMiddleware = require(&apos;http-proxy-middleware&apos;)// 使用 dev 环境的 webpack 配置var webpackConfig = require(&apos;./webpack.dev.conf&apos;)// 如果没有指定运行端口，使用 config.dev.port 作为运行端口var port = process.env.PORT || config.dev.port// Define HTTP proxies to your custom API backend// https://github.com/chimurai/http-proxy-middleware// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置var proxyTable = config.dev.proxyTable// 使用 express 启动一个服务var app = express()// 启动 webpack 进行编译var compiler = webpack(webpackConfig)// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中var devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, &#123; publicPath: webpackConfig.output.publicPath, stats: &#123; colors: true, chunks: false &#125;&#125;)// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reloadvar hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)// force page reload when html-webpack-plugin template changescompiler.plugin(&apos;compilation&apos;, function (compilation) &#123; compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) &#123; hotMiddleware.publish(&#123; action: &apos;reload&apos; &#125;) cb() &#125;)&#125;)// proxy api requests// 将 proxyTable 中的请求配置挂在到启动的 express 服务上Object.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] if (typeof options === &apos;string&apos;) &#123; options = &#123; target: options &#125; &#125; app.use(proxyMiddleware(context, options))&#125;)// handle fallback for HTML5 history API// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址app.use(require(&apos;connect-history-api-fallback&apos;)())// serve webpack bundle output// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上app.use(devMiddleware)// enable hot-reload and state-preserving// compilation error display// 将 Hot-reload 挂在到 express 服务上app.use(hotMiddleware)// serve pure static assets// 拼接 static 文件夹的静态资源路径var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)// 为静态资源提供响应服务app.use(staticPath, express.static(&apos;./static&apos;))// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err) return &#125; var uri = &apos;http://localhost:&apos; + port console.log(&apos;Listening at &apos; + uri + &apos;\n&apos;) // when env is testing, don&apos;t need open it // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址 if (process.env.NODE_ENV !== &apos;testing&apos;) &#123; opn(uri) &#125;&#125;) 让我们来看一下webpack的基础配置文件webpack.base.config.js1234567891011121314151617181920212223242526272829...module.export = &#123; // 入口文件 entry: &#123;&#125;, // 输出路径 output: &#123;&#125;, // 放置解决方案配置 resolve: &#123;&#125;, resolveLoader: &#123;&#125;, module: &#123; // 各种不同类型文件加载器配置 loaders: &#123; ... ... // js文件用babel转码 &#123; test: /\.js$/, loader: &apos;babel&apos;, include: projectRoot, // 不需要转码的文件 exclude: /node_modules/ &#125;, ... ... &#125; &#125;, // 配置一些相关的vue文件 vue: &#123;&#125;&#125; babelrc-用来将ES6代码转换为ES5格式来提高浏览器兼容性工具1234567891011121314151617&#123; //设定转码规则 &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;modules&quot;: false &#125;], &quot;stage-2&quot; ], //转码用的插件 &quot;plugins&quot;: [&quot;transform-runtime&quot;], &quot;comments&quot;: false, //对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作 &quot;env&quot;: &#123; &quot;test&quot;: &#123; &quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;], &quot;plugins&quot;: [ &quot;istanbul&quot; ] &#125; &#125;&#125; edirotconfig-定义项目内编码规范的配置文件123456789root = true[*] // 对所有文件应用下面的规则charset = utf-8 // 编码规则用utf-8indent_style = space // 缩进用空格indent_size = 2 // 缩进数量为2个空格end_of_line = lf // 换行符格式insert_final_newline = true // 是否在文件的最后插入一个空行trim_trailing_whitespace = true // 是否删除行尾的空格 src文件本文件夹用于开发 main.js12345678910111213import Vue from &apos;vue&apos; import App from &apos;./App&apos;import router from &apos;./router&apos;Vue.config.productionTip = false //生产环境提示，这里设置成了false/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;) main.js是程序的入口文件 APP.vue1234567891011121314151617181920212223&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; app.vue是页面的入口文件，不同路由加载出来的内容可以放到router标签里面来实现显示不同的内容。 router/index.js很明显，根据文件夹的名字就可以看出来，这是一个路由配置文件 hello.vue文件最后剩下的这个就是我们的页面文件了]]></content>
      <tags>
        <tag>vue框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-4chapter-v-bind&class&style]]></title>
    <url>%2F2017%2F12%2F05%2Fvue-4chapter-v-bind%2F</url>
    <content type="text"><![CDATA[第四章v-bind及class与style绑定4.1绑定class的几种方式 1&lt;div :class=&quot;&#123;&apos;active&apos;:isActive&#125;&quot;&gt;&lt;/div&gt; 上述示例，当实例中的isActive数据为true的时候会自动帮div添加一个active类同样，也可以在对象中传入多个属性来动态切换class，而且:class可以与普通的class共存1&lt;div :class=&quot;&#123;&apos;active&apos;:isActive,&apos;error&apos;:isError&#125;&quot;&gt;&lt;/div&gt; 当:class的表达式过长或逻辑复杂时，还可以绑定一个计算属性，这是一种很友好和常见的用法，一般当条件多于两个时，都可以使用data或computed例如：1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;div :class=&quot;classes&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:&apos;#app&apos;, data:&#123; isActive : true, isError : null &#125;, computed:&#123; classes:function()&#123; return &#123; active: this.isActive &amp;&amp; !this.error, &apos;text-fail&apos;:this.error &amp;&amp; this.error.type === &apos;fail&apos; &#125; &#125; &#125; &#125;)&lt;/script&gt; 可以使用三元表达式来根据条件切换class1&lt;div :class=&quot;[isActive ? activesCls : &apos;&apos;]&quot;&gt;&lt;/div&gt; 当然，class也可以使用computed和methods，这样加上data一共有三种方法来使用 在组件上使用:class Vue.component(‘my-component’,{ template: “一些文本“}); var app=new Vue({ el:"#app", data:{ isActive:true } })]]></content>
      <tags>
        <tag>vue实战学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-3chapter-computed]]></title>
    <url>%2F2017%2F12%2F05%2Fvue-3chapter-computed%2F</url>
    <content type="text"><![CDATA[##第三章 计算属性 3.1什么是计算属性计算属性computed 是为了解决复杂的逻辑语句，使得vue模板中的语句不是那么臃肿和难以阅读 3.2计算属性的用法计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，但是最终要返回一个结果。 计算属性中默认有getter和setter方法，get用来读取，set在写入时会触发，默认情况下会调用get方法123456789101112computed:&#123; fullName:&#123; get:function()&#123; return this.firstName+&apos; &apos;+this.lastName; &#125;, set:function(newValue)&#123; var names = newValue.split(&apos; &apos;); this.firstName = names[0]; this.lastName = names[names.length-1]; &#125; &#125;&#125; 计算属性还有两个很实用的小技巧： 计算属性可以依赖其他的计算属性 计算属性还可以依赖其它实例的数据 3.3计算属性缓存我们仔细思考不难发现，计算属性实现的功能method方法同样可以实现，那么我们为什么还要使用计算属性呢？ 原因就是计算属性是基于他的依赖来缓存的。一个计算属性所依赖的数据发生变化时，它才会重新取值，所以只要依赖不改变，计算属性也就不更新。]]></content>
      <tags>
        <tag>vue实战学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp工具的具体使用指南]]></title>
    <url>%2F2017%2F12%2F03%2Fgulp%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[全局安装gulp 1npm i -g gulp 将gulp作为项目的开发依赖 1npm install -D gulp 初始化gulpfile.js 在项目根目录下新建一个gulpfile.js文件 在gulpfile.js中引入gulp 使用gulp的task方法创建一个打包任务 在script任务中添加代码打包方法添加一个gulp-load-plugins 这个插件能极大的简化我们的工作流程，他的作用是自动引入我们所安装的所有gulp插件，然后我们只需要在头部引入一下这个插件，然后可以通过这个插件名调用我们引入的插件。 添加一个插件gulp-concat 这个插件可以让gulp拥有合并几个文件的功能 添加一个插件，安装依赖gulp-plumber 这个插件的作用简单来说就是一旦pipe中的某一steam报错了，保证下面的steam还继续执行 再添加一个代码压缩插件gulp-uglify uglify顾名思义就是丑化代码，让代码格式消失，压缩代码 然后去使用插件并完成压缩打包任务 配置执行打包任务使用gulp.task创建任务 然后我们在gulpfile.js同目录下执行打包命令这样我们的代码就打包成功了，可以看到dist和build文件夹下都自动生成了我们打包的代码 实现文件保存自动压缩 添加一个gulp任务，并在任务里添加一个watch事件去监听文件的变化，当文件变化时去执行指定的任务即完成了代码的自动打包 还有一件很重要的事情叫做添加默认任务 在实际工作中，别人可能不知道我们都定义了那些任务，所以我们要添加一个默认任务，让这个默认任务去执行我们想要执行的任务这样就完成了,我们在之前的命令行执行 1gulp default]]></content>
      <categories>
        <category>gulp教程</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何自己搭建一个angular脚手架]]></title>
    <url>%2F2017%2F12%2F02%2Fangular1.0%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本次以angular1.0脚手架为例 首先明确目录结构1234567891011121314151617181920212223242526configbuilddist static js all.min.js bundle.js style bundle.css index.htmlsrc controller ActivityCtrl.js ActivityCtrl.js service ActivityService.js ActivityService.js ActivityService.js app.js route.js view user user.html userAdd.html activity index.html 项目根目录下 一个配置文件夹conf 一个本地开发文件存放位置build 一个线上运行文件存放位置dist 一个本地编辑的源文件目录src 一个视图文件夹 cd进项目文件后执行命令行创建基本框架文件夹1mkdir -p dist config build src/&#123;controller,service,view/&#123;user,activity&#125;&#125; 完善相关src目录 创建入口文件app.js 12cd src/touch app.js 创建路由文件 1touch route.js 创建controller和service文件夹 1mkdir controllers services 根据相关功能添加相应文件及目录]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
</search>
